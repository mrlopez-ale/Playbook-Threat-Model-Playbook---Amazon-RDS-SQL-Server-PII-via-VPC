# Code Step 1
Step 1: Vulnerable Python/Flask Code (SQLi)
# app.py
# This code demonstrates a simple Flask application with a SQL injection vulnerability.
# The application uses an in-memory SQLite database to store product information.
# The vulnerability is present in the endpoint that retrieves product details based on a user-provided ID.
# The code is intentionally insecure to demonstrate the SQL injection vulnerability.
# It is not intended for production use and should be secured before deployment.
# The code includes logging for better traceability and debugging.
# Import necessary libraries

import sqlite3
from flask import Flask, request, jsonify
import logging # Added for logging

app = Flask(__name__)
logging.basicConfig(level=logging.INFO) # Basic logging setup

# Database setup (in-memory for simplicity)
def init_db():
    """Initializes an in-memory SQLite database with a products table."""
    # Use check_same_thread=False for simplicity in this demo,
    # allowing the web server thread to access the connection.
    # In real apps, manage connections per request context.
    conn = sqlite3.connect(':memory:', check_same_thread=False)
    cursor = conn.cursor()
    try:
        # Create the products table
        cursor.execute("CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)")
        # Insert some sample data
        cursor.execute("INSERT INTO products (id, name, price) VALUES (?, ?, ?)", (1, 'Gadget', 19.99))
        cursor.execute("INSERT INTO products (id, name, price) VALUES (?, ?, ?)", (2, 'Widget', 25.50))
        conn.commit() # Save changes
        logging.info("In-memory database initialized with products table and sample data.")
    except sqlite3.Error as e:
        logging.error(f"Database initialization error: {e}")
        raise # Re-raise the exception if init fails
    return conn

# Establish connection when the application starts
try:
    db_conn = init_db()
except sqlite3.Error:
    db_conn = None # Handle case where DB init fails gracefully
    logging.error("FATAL: Failed to initialize database connection during startup.")

# --- VULNERABLE ENDPOINT ---
@app.route('/product_vulnerable/<product_id>')
def get_product_vulnerable(product_id):
    """
    Fetches product by ID using the provided product_id from the URL.
    THIS ENDPOINT IS VULNERABLE TO SQL INJECTION.
    It uses an f-string to directly format the user-provided 'product_id'
    into the SQL query string, without sanitization or parameterization.
    """
    # Check if the database connection was successfully established at startup
    if not db_conn:
        return jsonify({"error": "Database connection not available"}), 503 # Service Unavailable

    cursor = db_conn.cursor()

    # !!! VULNERABLE LINE !!!
    # The 'product_id' variable, which comes directly from the URL path
    # (and is thus controlled by the user/attacker), is formatted directly
    # into the SQL query string using an f-string.
    # This allows an attacker to inject SQL syntax. For example, if
    # product_id is "1 OR 1=1", the query becomes:
    # "SELECT id, name, price FROM products WHERE id = 1 OR 1=1"
    # which bypasses the intended ID check.
    query = f"SELECT id, name, price FROM products WHERE id = {product_id}"
    # !!! END VULNERABLE LINE !!!

    try:
        # Log the exact query being executed for demonstration purposes
        app.logger.info(f"Executing vulnerable query: {query}")
        cursor.execute(query) # Execute the potentially manipulated query
        product = cursor.fetchone() # Fetch the first result

        if product:
            # If a product is found, return its details as JSON
            return jsonify({"id": product[0], "name": product[1], "price": product[2]})
        else:
            # If no product is found, log a warning if the input was non-numeric
            # (often happens after a failed injection attempt or invalid input)
            if not product_id.isdigit():
                 app.logger.warning(f"Non-numeric product_id received: {product_id}")
            # Return a standard 404 Not Found error
            return jsonify({"error": "Product not found"}), 404

    except sqlite3.Error as e:
        # Catch potential database errors (e.g., syntax errors caused by injection)
        app.logger.error(f"Database error for query '{query}' with input '{product_id}': {e}")
        # Return a generic server error response
        return jsonify({"error": "Database query failed due to invalid input or syntax"}), 500
    finally:
        # Ensure the cursor is closed after use
        # Note: In more complex Flask apps, connection/cursor management
        # is often handled using Flask's application context features.
        if cursor:
           cursor.close()


# Main execution block to run the Flask development server
if __name__ == '__main__':
    # Only start the server if the database was initialized successfully
    if not db_conn:
        print("ERROR: Could not initialize database. Flask application cannot start.")
    else:
        print("="*50)
        print("Database initialized successfully.")
        print("Starting Flask development server...")
        print("Access the vulnerable endpoint in your browser or with curl:")
        print("  Example (valid): http://127.0.0.1:5000/product_vulnerable/1")
        print("  Example (valid): http://127.0.0.1:5000/product_vulnerable/2")
        print("  Example (injection): http://127.0.0.1:5000/product_vulnerable/1%20OR%201=1")
        print("  Example (injection): http://127.0.0.1:5000/product_vulnerable/0%20UNION%20SELECT%201,sql,sqlite_version()%20FROM%20sqlite_master--")
        print("Press CTRL+C to stop the server.")
        print("="*50)
        # Run the app in debug mode (provides automatic reloading and more detailed error pages)
        # Note: Debug mode should NOT be used in production environments.
        app.run(debug=True)
